<!DOCTYPE html>
<html lang='en'>
  <head>
    <title>A story of compromises and types - The Crystal Programming Language</title>
    <meta charset='utf-8'>
    <!-- Import Google Icon Font -->
    <link href='https://fonts.googleapis.com/icon?family=Material+Icons|Roboto+Mono' rel='stylesheet'>
    <link href="/assets/stylesheet.css" rel="stylesheet" />
    <link href='/feed.xml' rel='alternate' title='Atom 1.0' type='application/atom+xml'>
    <link href='/favicon.png' rel='icon' type='image/png'>
    <link href='/favicon.ico' rel='shortcut icon' type='image/x-icon'>
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>A story of compromises and types | プログラミング言語 Crystal</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="A story of compromises and types" />
<meta name="author" content="bcardiff" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Let’s play with an immutable Queue type. We want to:" />
<meta property="og:description" content="Let’s play with an immutable Queue type. We want to:" />
<link rel="canonical" href="https://ja.crystal-lang.org/2016/09/09/a-story-of-compromises-and-types.html" />
<meta property="og:url" content="https://ja.crystal-lang.org/2016/09/09/a-story-of-compromises-and-types.html" />
<meta property="og:site_name" content="プログラミング言語 Crystal" />
<meta property="og:image" content="https://ja.crystal-lang.org/assets/icon.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-09-09T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://ja.crystal-lang.org/assets/icon.png" />
<meta property="twitter:title" content="A story of compromises and types" />
<meta name="twitter:site" content="@CrystalLanguage" />
<meta name="twitter:creator" content="@bcardiff" />
<script type="application/ld+json">
{"datePublished":"2016-09-09T00:00:00+00:00","dateModified":"2016-09-09T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ja.crystal-lang.org/2016/09/09/a-story-of-compromises-and-types.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://ja.crystal-lang.org/assets/media/crystal_logo.svg"},"name":"bcardiff"},"url":"https://ja.crystal-lang.org/2016/09/09/a-story-of-compromises-and-types.html","author":{"@type":"Person","name":"bcardiff"},"@type":"BlogPosting","image":"https://ja.crystal-lang.org/assets/icon.png","headline":"A story of compromises and types","description":"Let’s play with an immutable Queue type. We want to:","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Let browser know website is optimized for mobile -->
    <meta content='width=device-width, initial-scale=1.0' name='viewport'>
    <script src='https://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript'></script>
  </head>
  <body>
    <div class="wrapper ">
  <nav role='navigation'>
  <div class='nav-wrapper no-select'>
    
      <a class='brand-logo' id='logo-container'>
        <canvas height='120' id='logo-canvas' style='cursor:move' width='120'></canvas>
      </a>
    
    <ul class='right hide-on-med-and-down' id='nav-desktop'>
      
<li>
    <a href="/">
      Home
    </a>
  </li>
<li>
    <a href="https://forum.crystal-lang.org" target="_blank">
      Forum
    </a>
  </li>
<li>
    <a href="/blog/">
      Blog
    </a>
  </li>
<li>
    <a href="/sponsors/">
      Sponsors
    </a>
  </li>
<li>
    <a href="/community/">
      Community
    </a>
  </li>
<li>
    <a href="/conference/">
      Conference
    </a>
  </li>
<li>
    <a href="/team/">
      Team
    </a>
  </li>
<li>
    <a href="/docs/">
      Docs
    </a>
  </li>
<li>
    <a href="https://github.com/crystal-lang/crystal" target="_blank">
      GitHub
    </a>
  </li>


    </ul>
    <ul class='side-nav' id='nav-mobile'>
      
<li>
    <a href="/">
      Home
    </a>
  </li>
<li>
    <a href="https://forum.crystal-lang.org" target="_blank">
      Forum
    </a>
  </li>
<li>
    <a href="/blog/">
      Blog
    </a>
  </li>
<li>
    <a href="/sponsors/">
      Sponsors
    </a>
  </li>
<li>
    <a href="/community/">
      Community
    </a>
  </li>
<li>
    <a href="/conference/">
      Conference
    </a>
  </li>
<li>
    <a href="/team/">
      Team
    </a>
  </li>
<li>
    <a href="/docs/">
      Docs
    </a>
  </li>
<li>
    <a href="https://github.com/crystal-lang/crystal" target="_blank">
      GitHub
    </a>
  </li>


    </ul>
    <a class='button-collapse' data-activates='nav-mobile' href='#'>
      <i class='material-icons'>menu</i>
    </a>
  </div>
</nav>


  <div class='post-header'>
  <div class="container">
    <div class='valign row'>
      <div class="col m2"></div>
      <div class="col s12 m9">
        <div class="author small">
          
          
            <img src="/assets/authors/bcardiff.jpg" />
          
          
            <span class="author_name">Brian J. Cardiff</span>
          
          <span class="date">09 Sep 2016</span>
        </div>

        <h1 class='title'>A story of compromises and types</h1>
      </div>
      <div class="col m1"></div>
    </div>
  </div>
</div>


<main>
  <div class="container">
    <div class="row post-layout">
      <div class="col m2 share">
        <p class="title small share-title">Share</p>
        <div class="share-list">
          
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fja.crystal-lang.org%2F2016%2F09%2F09%2Fa-story-of-compromises-and-types.html&text=A+story+of+compromises+and+types&via=CrystalLanguage" target="_blank">
            <div class="share-item"><i class="extra-icons twitter gray"></i></div>
          </a>
          <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fja.crystal-lang.org%2F2016%2F09%2F09%2Fa-story-of-compromises-and-types.html" target="_blank">
            <div class="share-item"><i class="extra-icons facebook gray"></i></div>
          </a>
          <a href="https://plus.google.com/share?url=https%3A%2F%2Fja.crystal-lang.org%2F2016%2F09%2F09%2Fa-story-of-compromises-and-types.html" target="_blank">
            <div class="share-item"><i class="extra-icons google_plus gray"></i></div>
            </a>
        </div>
      </div>

      <div class="col s12 m9">
        <p>Let’s play with an immutable Queue type. We want to:</p>

<ol>
  <li>Create an empty queue</li>
  <li>Push things into a queue and get a new queue with the added element</li>
  <li>Pop the next element of the queue and also get the rest of the queue.</li>
</ol>

<p>So something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="n">q</span> <span class="o">=</span> <span class="n">build_queue</span>  <span class="c1"># q = {}</span>
<span class="n">new_q</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">push</span> <span class="mi">2</span> <span class="c1"># q = {2}</span>
<span class="n">e</span><span class="p">,</span> <span class="n">old_q</span> <span class="o">=</span> <span class="n">new_q</span><span class="p">.</span><span class="nf">pop</span> <span class="c1"># e = 2, q = {}</span>
</code></pre></div></div>

<p>If we jump into creating a Queue class we will get the following skeleton:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="k">class</span> <span class="nc">Queue</span>
  <span class="c1"># returns a new queue with `e` at the beginning</span>
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="c1"># returns the next element and a queue</span>
  <span class="c1"># with the remaining elements</span>
  <span class="c1"># fails if queue is empty</span>
  <span class="k">def</span> <span class="nf">pop</span>
    <span class="k">raise</span> <span class="no">EmptyQueueRuntimeError</span><span class="p">.</span><span class="nf">new</span> <span class="k">if</span> <span class="n">empty?</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This could work. However, there are some kinds of programs that will compile, but will <em>always</em> fail to run:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="n">q</span> <span class="o">=</span> <span class="no">Queue</span><span class="p">.</span><span class="nf">new</span>
<span class="n">e</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">pop</span> <span class="c1"># =&gt; EmptyQueueRuntimeError :-(</span>
</code></pre></div></div>

<p>Going in a a similar direction of the <a href="/2013/07/13/null-pointer-exception.html">NullPointerException</a>, we could try to split the queue values that will help us move from this <code class="language-crystal highlighter-rouge"><span class="no">EmptyQueueRuntimeError</span></code> to a compile error. For that, we need to differentiate the <code class="language-crystal highlighter-rouge"><span class="no">EmptyQueue</span></code> from the non-empty Queues.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="k">class</span> <span class="nc">EmptyQueue</span>
  <span class="c1"># Always return a Queue</span>
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Queue</span>
  <span class="c1"># Always return a Queue</span>
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="c1"># Return Queue or EmptyQueue</span>
  <span class="k">def</span> <span class="nf">pop</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">q</span> <span class="o">=</span> <span class="no">EmptyQueue</span><span class="p">.</span><span class="nf">new</span>
<span class="n">q</span><span class="p">.</span><span class="nf">pop</span> <span class="c1"># =&gt; Compile Error :-) EmptyQueue does not have EmptyQueue#pop</span>
</code></pre></div></div>

<p>But is it really useful?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="n">q0</span> <span class="o">=</span> <span class="no">EmptyQueue</span><span class="p">.</span><span class="nf">new</span>   <span class="c1"># q0 = {}</span>
<span class="n">q1</span> <span class="o">=</span> <span class="n">q0</span><span class="p">.</span><span class="nf">push</span> <span class="mi">1</span>        <span class="c1"># q1 = {1}</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">q1</span><span class="p">.</span><span class="nf">push</span> <span class="mi">2</span>        <span class="c1"># q2 = {2, 1}</span>
<span class="n">e</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">q2</span><span class="p">.</span><span class="nf">pop</span>        <span class="c1"># q3 = {1}, e = 2</span>
<span class="n">e</span><span class="p">,</span> <span class="n">q4</span> <span class="o">=</span> <span class="n">q3</span><span class="p">.</span><span class="nf">pop</span>        <span class="c1"># =&gt; Compile Error :-( , but *we* know q3 is not empty...</span>
</code></pre></div></div>

<p>The compile error is because <code class="language-crystal highlighter-rouge"><span class="n">typeof</span><span class="p">(</span><span class="n">q3</span><span class="p">)</span> <span class="o">::</span> <span class="no">EmptyQueue</span> <span class="o">|</span> <span class="no">Queue</span></code>.</p>

<p>The fact that popping from a nonempty queue <em>may</em> lead to an empty queue stands between us and what we want to do. A “<em>may</em> lead” is translated to the return type since it is one of the possible results in runtime.</p>

<p>We could try to do something <em>crazy</em>. What if <code class="language-crystal highlighter-rouge"><span class="no">Queue</span></code> contains the amount of elements in its type. We know that if you:</p>

<ol>
  <li>Push an element to a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span></code>, you will get a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></code></li>
  <li>Pop from a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code>, you will get an <code class="language-crystal highlighter-rouge"><span class="no">EmptyQueue</span></code></li>
  <li>Pop from a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span></code> with <code class="language-crystal highlighter-rouge"><span class="no">N</span> <span class="o">&gt;</span> <span class="mi">1</span></code>, you wil get a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></code></li>
</ol>

<p>It seems reasonable (and a bit crazy).</p>

<p>In a static typed language the compiler will use the types of the expressions. It won’t, since it can’t, rely on their actual values because those will only appear during execution. Programmers can <em>deduce</em> a certain behaviour of a program that holds for all possible executions, but this analysis goes beyond just the types of the expressions. This is something hard to realise if you are only used to dynamic languages. What we are trying to do is to take a bit more of information from the queues and add it to the <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span></code> type, so that the compiler will be able to use the information of the types to <em>decide</em> if the program does actually makes sense and hence compiles.</p>

<p>For this we will need:</p>

<ul>
  <li>A way to declare overloads <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code> and <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span></code> (with <code class="language-crystal highlighter-rouge"><span class="no">N</span> <span class="o">&gt;</span> <span class="mi">1</span></code>)</li>
  <li>Be able to use Math operators in types: given <code class="language-crystal highlighter-rouge"><span class="no">N</span></code>, return <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></code>.
    <ul>
      <li>And teach the type inference how to deduce these things so we don’t need to always write them.</li>
    </ul>
  </li>
</ul>

<p>Even if we added this, it’s a risky business: Let’s imagine we want a <code class="language-crystal highlighter-rouge"><span class="c1">#filter</span></code> operation that will remove from the queue all elements that are equal to a certain value. What will be the return type of <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span><span class="c1">#filter(e)</span></code>?</p>

<p>Potentially <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span> <span class="o">|</span> <span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="o">....</span> <span class="o">|</span> <span class="no">Queue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="no">EmptyQueue</span></code>.
Or even <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">-</span><span class="no">R</span><span class="p">)</span></code> where <code class="language-crystal highlighter-rouge"><span class="no">R</span><span class="o">=</span><span class="c1">#count of e in self</span></code>.
See? <em>scary</em> 👻.</p>

<p>Types are powerful stuff.</p>

<p>There is a lot of theory behind type systems. This story grazes <a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types system</a>.</p>

<p>Types group values and serve as a basis for static analysis. Analysis that won’t depend on the actual values.</p>

<p>If the type goes into too much detail, then it will be a pain to use.
It the type ignores lots of details, then we will get lots of exceptions in runtime.</p>

<p>This situation has been coming up all the time since we began designing Crystal’s type system and API. We aim to define a useful type system that will help programmers catch runtime exceptions, but we want it to be usable and easy-going. That is why:</p>

<ul>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Nil</span></code> is not a value of every type <code class="language-crystal highlighter-rouge"><span class="no">T</span></code>. You need to use unions of <code class="language-crystal highlighter-rouge"><span class="no">T</span> <span class="o">|</span> <span class="no">Nil</span></code> (or <code class="language-crystal highlighter-rouge"><span class="no">T</span><span class="p">?</span></code>)</li>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">)</span></code> is able to hold only one type (although it can be a union), but we don’t know which indices are valid in compile time.</li>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Tuples</span><span class="p">(</span><span class="o">*</span><span class="no">T</span><span class="p">)</span></code> are not as flexible as an <code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">)</span></code> but given a literal we can know if it is a valid index and which type it corresponds to in compile time.</li>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">)</span></code>/<code class="language-crystal highlighter-rouge"><span class="no">Tuple</span><span class="p">(</span><span class="o">*</span><span class="no">T</span><span class="p">)</span></code> relationship is analogous to <code class="language-crystal highlighter-rouge"><span class="no">Hash</span><span class="p">(</span><span class="no">K</span><span class="p">,</span><span class="no">V</span><span class="p">)</span></code>/<code class="language-crystal highlighter-rouge"><span class="no">NamedTuple</span><span class="p">(</span><span class="o">**</span><span class="no">T</span><span class="p">)</span></code>.</li>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">?)</span><span class="c1">#compact</span></code> returns an <code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">)</span></code></li>
</ul>

<p>Although the <code class="language-crystal highlighter-rouge"><span class="no">Queue</span></code> story didn’t end up so well, it did end up well for all of the above types,
allowing us to have a happy time while crystalling. Success!</p>


      </div>
      <div class="col m1"></div>
    </div>

    <div class="row disqus">
      <div class="col m2"></div>
      <div class="col s12 m9" id='disqus_thread'>
        <p>Let’s play with an immutable Queue type. We want to:</p>

<ol>
  <li>Create an empty queue</li>
  <li>Push things into a queue and get a new queue with the added element</li>
  <li>Pop the next element of the queue and also get the rest of the queue.</li>
</ol>

<p>So something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="n">q</span> <span class="o">=</span> <span class="n">build_queue</span>  <span class="c1"># q = {}</span>
<span class="n">new_q</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">push</span> <span class="mi">2</span> <span class="c1"># q = {2}</span>
<span class="n">e</span><span class="p">,</span> <span class="n">old_q</span> <span class="o">=</span> <span class="n">new_q</span><span class="p">.</span><span class="nf">pop</span> <span class="c1"># e = 2, q = {}</span>
</code></pre></div></div>

<p>If we jump into creating a Queue class we will get the following skeleton:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="k">class</span> <span class="nc">Queue</span>
  <span class="c1"># returns a new queue with `e` at the beginning</span>
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="c1"># returns the next element and a queue</span>
  <span class="c1"># with the remaining elements</span>
  <span class="c1"># fails if queue is empty</span>
  <span class="k">def</span> <span class="nf">pop</span>
    <span class="k">raise</span> <span class="no">EmptyQueueRuntimeError</span><span class="p">.</span><span class="nf">new</span> <span class="k">if</span> <span class="n">empty?</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This could work. However, there are some kinds of programs that will compile, but will <em>always</em> fail to run:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="n">q</span> <span class="o">=</span> <span class="no">Queue</span><span class="p">.</span><span class="nf">new</span>
<span class="n">e</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">pop</span> <span class="c1"># =&gt; EmptyQueueRuntimeError :-(</span>
</code></pre></div></div>

<p>Going in a a similar direction of the <a href="/2013/07/13/null-pointer-exception.html">NullPointerException</a>, we could try to split the queue values that will help us move from this <code class="language-crystal highlighter-rouge"><span class="no">EmptyQueueRuntimeError</span></code> to a compile error. For that, we need to differentiate the <code class="language-crystal highlighter-rouge"><span class="no">EmptyQueue</span></code> from the non-empty Queues.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="k">class</span> <span class="nc">EmptyQueue</span>
  <span class="c1"># Always return a Queue</span>
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Queue</span>
  <span class="c1"># Always return a Queue</span>
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="c1"># Return Queue or EmptyQueue</span>
  <span class="k">def</span> <span class="nf">pop</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">q</span> <span class="o">=</span> <span class="no">EmptyQueue</span><span class="p">.</span><span class="nf">new</span>
<span class="n">q</span><span class="p">.</span><span class="nf">pop</span> <span class="c1"># =&gt; Compile Error :-) EmptyQueue does not have EmptyQueue#pop</span>
</code></pre></div></div>

<p>But is it really useful?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="code_section"><code><span class="n">q0</span> <span class="o">=</span> <span class="no">EmptyQueue</span><span class="p">.</span><span class="nf">new</span>   <span class="c1"># q0 = {}</span>
<span class="n">q1</span> <span class="o">=</span> <span class="n">q0</span><span class="p">.</span><span class="nf">push</span> <span class="mi">1</span>        <span class="c1"># q1 = {1}</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">q1</span><span class="p">.</span><span class="nf">push</span> <span class="mi">2</span>        <span class="c1"># q2 = {2, 1}</span>
<span class="n">e</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">q2</span><span class="p">.</span><span class="nf">pop</span>        <span class="c1"># q3 = {1}, e = 2</span>
<span class="n">e</span><span class="p">,</span> <span class="n">q4</span> <span class="o">=</span> <span class="n">q3</span><span class="p">.</span><span class="nf">pop</span>        <span class="c1"># =&gt; Compile Error :-( , but *we* know q3 is not empty...</span>
</code></pre></div></div>

<p>The compile error is because <code class="language-crystal highlighter-rouge"><span class="n">typeof</span><span class="p">(</span><span class="n">q3</span><span class="p">)</span> <span class="o">::</span> <span class="no">EmptyQueue</span> <span class="o">|</span> <span class="no">Queue</span></code>.</p>

<p>The fact that popping from a nonempty queue <em>may</em> lead to an empty queue stands between us and what we want to do. A “<em>may</em> lead” is translated to the return type since it is one of the possible results in runtime.</p>

<p>We could try to do something <em>crazy</em>. What if <code class="language-crystal highlighter-rouge"><span class="no">Queue</span></code> contains the amount of elements in its type. We know that if you:</p>

<ol>
  <li>Push an element to a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span></code>, you will get a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></code></li>
  <li>Pop from a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code>, you will get an <code class="language-crystal highlighter-rouge"><span class="no">EmptyQueue</span></code></li>
  <li>Pop from a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span></code> with <code class="language-crystal highlighter-rouge"><span class="no">N</span> <span class="o">&gt;</span> <span class="mi">1</span></code>, you wil get a <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></code></li>
</ol>

<p>It seems reasonable (and a bit crazy).</p>

<p>In a static typed language the compiler will use the types of the expressions. It won’t, since it can’t, rely on their actual values because those will only appear during execution. Programmers can <em>deduce</em> a certain behaviour of a program that holds for all possible executions, but this analysis goes beyond just the types of the expressions. This is something hard to realise if you are only used to dynamic languages. What we are trying to do is to take a bit more of information from the queues and add it to the <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span></code> type, so that the compiler will be able to use the information of the types to <em>decide</em> if the program does actually makes sense and hence compiles.</p>

<p>For this we will need:</p>

<ul>
  <li>A way to declare overloads <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code> and <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span></code> (with <code class="language-crystal highlighter-rouge"><span class="no">N</span> <span class="o">&gt;</span> <span class="mi">1</span></code>)</li>
  <li>Be able to use Math operators in types: given <code class="language-crystal highlighter-rouge"><span class="no">N</span></code>, return <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></code>.
    <ul>
      <li>And teach the type inference how to deduce these things so we don’t need to always write them.</li>
    </ul>
  </li>
</ul>

<p>Even if we added this, it’s a risky business: Let’s imagine we want a <code class="language-crystal highlighter-rouge"><span class="c1">#filter</span></code> operation that will remove from the queue all elements that are equal to a certain value. What will be the return type of <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span><span class="c1">#filter(e)</span></code>?</p>

<p>Potentially <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="p">)</span> <span class="o">|</span> <span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="o">....</span> <span class="o">|</span> <span class="no">Queue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="no">EmptyQueue</span></code>.
Or even <code class="language-crystal highlighter-rouge"><span class="no">Queue</span><span class="p">(</span><span class="no">N</span><span class="o">-</span><span class="no">R</span><span class="p">)</span></code> where <code class="language-crystal highlighter-rouge"><span class="no">R</span><span class="o">=</span><span class="c1">#count of e in self</span></code>.
See? <em>scary</em> 👻.</p>

<p>Types are powerful stuff.</p>

<p>There is a lot of theory behind type systems. This story grazes <a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types system</a>.</p>

<p>Types group values and serve as a basis for static analysis. Analysis that won’t depend on the actual values.</p>

<p>If the type goes into too much detail, then it will be a pain to use.
It the type ignores lots of details, then we will get lots of exceptions in runtime.</p>

<p>This situation has been coming up all the time since we began designing Crystal’s type system and API. We aim to define a useful type system that will help programmers catch runtime exceptions, but we want it to be usable and easy-going. That is why:</p>

<ul>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Nil</span></code> is not a value of every type <code class="language-crystal highlighter-rouge"><span class="no">T</span></code>. You need to use unions of <code class="language-crystal highlighter-rouge"><span class="no">T</span> <span class="o">|</span> <span class="no">Nil</span></code> (or <code class="language-crystal highlighter-rouge"><span class="no">T</span><span class="p">?</span></code>)</li>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">)</span></code> is able to hold only one type (although it can be a union), but we don’t know which indices are valid in compile time.</li>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Tuples</span><span class="p">(</span><span class="o">*</span><span class="no">T</span><span class="p">)</span></code> are not as flexible as an <code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">)</span></code> but given a literal we can know if it is a valid index and which type it corresponds to in compile time.</li>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">)</span></code>/<code class="language-crystal highlighter-rouge"><span class="no">Tuple</span><span class="p">(</span><span class="o">*</span><span class="no">T</span><span class="p">)</span></code> relationship is analogous to <code class="language-crystal highlighter-rouge"><span class="no">Hash</span><span class="p">(</span><span class="no">K</span><span class="p">,</span><span class="no">V</span><span class="p">)</span></code>/<code class="language-crystal highlighter-rouge"><span class="no">NamedTuple</span><span class="p">(</span><span class="o">**</span><span class="no">T</span><span class="p">)</span></code>.</li>
  <li><code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">?)</span><span class="c1">#compact</span></code> returns an <code class="language-crystal highlighter-rouge"><span class="no">Array</span><span class="p">(</span><span class="no">T</span><span class="p">)</span></code></li>
</ul>

<p>Although the <code class="language-crystal highlighter-rouge"><span class="no">Queue</span></code> story didn’t end up so well, it did end up well for all of the above types,
allowing us to have a happy time while crystalling. Success!</p>


      </div>
      <div class="col m1"></div>
    </div>
  </div>
</main>


  <footer>
  <div class="row">
    <div class="col s12 m12 l6 crystal">
      Crystal is licensed under the Apache License,
      <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>
        Version 2.0
      </a>
    </div>
    <div class="col s12 m12 l6 manas right-align black-text">
      Crystal language, born & raised at
      <a href="https://manas.tech" target="_blank" class="black-text">Manas</a>
      <a href="https://manas.tech" target="_blank" class="logo">
        <i class="manas"></i>
      </a>
    </div>
  </div>
</footer>

</div>


    <script src="/assets/js/bundle.js"></script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42353458-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>
</html>
